

/**
 * 策略模式：<br/>
 * 结构：<ol>
 *     <li>抽象策略（Strategy）: 抽象角色，通常由一个接口或抽象类实现。给出所有具体策略类所需的接口</li>
 *     <li>具体策略（Concrete Strategy）: 实现了抽象策略定义的接口，提供具体的算法和实现行为</li>
 *     <li>环境（Context）: 持有一个策略类给客户调用</li>
 * </ol>
 * 优点：<ol>
 *     <li>策略类之间可以自由切换：由于策略类都实现同一个接口，所以他们之间可以自由切换</li>
 *     <li>易于扩展：增加一个策略只需要添加具体类即可，基本不需要改变原有的代码，符合开闭原则</li>
 *     <li>避免使用多重条件选择语句，充分体现面向对象设计思想</li>
 * </ol>
 * 缺点：<ol>
 *     <li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类</li>
 *     <li>策略模式将造成产生很多策略类，可是通过使用享元模式在一定程度上减少对象的数量</li>
 * </ol>
 * 使用场景：<ol>
 *     <li>一个系统需要动态的在几种算法中选择一种时，可将每个算法封装到策略类中</li>
 *     <li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入他们各自的策略类中以代替这些语句</li>
 *     <li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时</li>
 *     <li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构</li>
 *     <li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为</li>
 * </ol>
 */
package behavior.strategy;
