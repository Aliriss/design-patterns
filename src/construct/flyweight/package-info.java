

/**
 * 享元模式：<br/>
 * 一、两种状态：<ol>
 *     <li>内部状态：不会随着环境的改变而改变的可共享部分</li>
 *     <li>外部状态：随环境改变而改变的不可共享的部分。</li>
 * </ol>
 * 二、角色：<ol>
 *     <li>抽象享元角色（FlyWeight）：通常是也给接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据，同时也可以根据这些方法来设置外部数据。</li>
 *     <li>具体享元角色（Concrete FlyWeight）：实现了抽象享元类，在具体享元类中为内部状态提供了存储空间。通常可以结合单例模式来设计具体享元类。</li>
 *     <li>非享元角色（Unsharable FlyWeight）：并不是所有抽象享元类的抽象子类都需要被共享，不能被共享的子类可设计为非共享具体享元类，可通过实例化创建。</li>
 *     <li>享元工厂（FlyWeight Factory）：负责创建和管理享元角色。</li>
 * </ol>
 * 三、优点：<ol>
 *     <li>极大减少内存中相同或相似对象数量，节约系统资源，提高系统性能</li>
 *     <li>享元模式中的外部状态相互独立，不影响内部状态</li>
 * </ol>
 * 四、缺点：<ol>
 *     <li>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部和外部状态，使程序逻辑复杂</li>
 * </ol>
 * 五、使用场景：<ol>
 *     <li>一个系统有大量相同或相似的对象，造成内存的大量耗费</li>
 *     <li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中</li>
 *     <li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要消耗一定的资源，因此，应当在需要多次重复使用享元对象时才值得使用享元对象</li>
 * </ol>
 * @author all
 * @since 2023/7/21 17:36
 */
package construct.flyweight;

